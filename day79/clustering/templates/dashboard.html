<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Log Clustering Dashboard - Day 79</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .header {
            background: rgba(255, 255, 255, 0.95);
            padding: 1rem 2rem;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            color: #2c3e50;
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }
        
        .header p {
            color: #7f8c8d;
            font-size: 1.1rem;
        }
        
        .header-controls {
            display: flex;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .btn-demo {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
        }
        
        .btn-demo:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }
        
        .btn-demo:active {
            transform: translateY(0);
        }
        
        .btn-stop-demo {
            background: linear-gradient(135deg, #95a5a6, #7f8c8d);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(149, 165, 166, 0.3);
        }
        
        .btn-stop-demo:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(149, 165, 166, 0.4);
        }
        
        .btn-stop-demo:active {
            transform: translateY(0);
        }
        
        .demo-active {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            }
            50% {
                box-shadow: 0 4px 15px rgba(231, 76, 60, 0.6);
            }
            100% {
                box-shadow: 0 4px 15px rgba(231, 76, 60, 0.3);
            }
        }
        
        .dashboard-container {
            padding: 2rem;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
        }
        
        .stat-card:hover {
            transform: translateY(-5px);
        }
        
        .stat-card h3 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 0.5rem;
        }
        
        .stat-description {
            color: #7f8c8d;
            font-size: 0.9rem;
        }
        
        .visualization-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }
        
        .chart-container h3 {
            color: #2c3e50;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }
        
        .pattern-discovery-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            margin-bottom: 2rem;
        }
        
        .pattern-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1.5rem;
            align-items: center;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        .pattern-filter {
            padding: 0.5rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: white;
            font-size: 0.9rem;
        }
        
        .patterns-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 1rem;
        }
        
        .pattern-card {
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 1rem;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .pattern-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
        }
        
        .pattern-card.error {
            border-left: 4px solid #e74c3c;
            background: linear-gradient(135deg, #fff5f5, #ffe6e6);
        }
        
        .pattern-card.security {
            border-left: 4px solid #f39c12;
            background: linear-gradient(135deg, #fffbf0, #fff3cd);
        }
        
        .pattern-card.performance {
            border-left: 4px solid #3498db;
            background: linear-gradient(135deg, #f0f8ff, #e3f2fd);
        }
        
        .pattern-card.general {
            border-left: 4px solid #2ecc71;
            background: linear-gradient(135deg, #f0fff4, #e8f5e8);
        }
        
        .pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.5rem;
        }
        
        .pattern-type {
            font-weight: bold;
            font-size: 1.1rem;
            color: #2c3e50;
        }
        
        .pattern-confidence {
            background: #3498db;
            color: white;
            padding: 0.2rem 0.5rem;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: bold;
        }
        
        .pattern-algorithm {
            color: #7f8c8d;
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
        }
        
        .pattern-samples {
            margin: 0.5rem 0;
        }
        
        .pattern-samples h4 {
            color: #2c3e50;
            font-size: 0.9rem;
            margin-bottom: 0.3rem;
        }
        
        .sample-log {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 0.5rem;
            margin-bottom: 0.3rem;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            color: #495057;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .pattern-features {
            margin-top: 0.5rem;
        }
        
        .pattern-features h4 {
            color: #2c3e50;
            font-size: 0.9rem;
            margin-bottom: 0.3rem;
        }
        
        .feature-bar {
            display: flex;
            align-items: center;
            margin-bottom: 0.2rem;
        }
        
        .feature-name {
            width: 80px;
            font-size: 0.8rem;
            color: #495057;
        }
        
        .feature-progress {
            flex: 1;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            margin: 0 0.5rem;
            overflow: hidden;
        }
        
        .feature-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .feature-value {
            font-size: 0.7rem;
            color: #6c757d;
            width: 30px;
            text-align: right;
        }
        
        .pattern-timestamp {
            color: #6c757d;
            font-size: 0.8rem;
            margin-top: 0.5rem;
            text-align: right;
        }
        
        .alerts-container {
            background: rgba(255, 255, 255, 0.95);
            padding: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
            margin-bottom: 2rem;
        }
        
        .alert-item {
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: 8px;
            border-left: 4px solid;
        }
        
        .alert-anomaly {
            background: #ffeaa7;
            border-left-color: #fdcb6e;
        }
        
        .alert-pattern {
            background: #a7f5ff;
            border-left-color: #00cec9;
        }
        
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: bold;
        }
        
        .connected {
            background: #00b894;
            color: white;
        }
        
        .disconnected {
            background: #e17055;
            color: white;
        }
        
        @media (max-width: 768px) {
            .visualization-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status" id="connection-status">Connecting...</div>
    
    <div class="header">
        <h1>üéØ Log Clustering Dashboard</h1>
        <p>Day 79: Pattern Discovery in Distributed Log Processing Systems</p>
        <div class="header-controls">
            <button id="demo-button" class="btn-demo">üé¨ Start Demo</button>
            <button id="stop-demo-button" class="btn-stop-demo" style="display: none;">‚èπÔ∏è Stop Demo</button>
        </div>
    </div>
    
    <div class="dashboard-container">
        <!-- Statistics Cards -->
        <div class="stats-grid">
            <div class="stat-card">
                <h3>Total Clusters</h3>
                <div class="stat-value" id="total-clusters">0</div>
                <div class="stat-description">Active pattern clusters</div>
            </div>
            
            <div class="stat-card">
                <h3>Patterns Discovered</h3>
                <div class="stat-value" id="patterns-discovered">0</div>
                <div class="stat-description">Unique patterns found</div>
            </div>
            
            <div class="stat-card">
                <h3>Anomalies Detected</h3>
                <div class="stat-value" id="anomalies-detected">0</div>
                <div class="stat-description">Unusual patterns identified</div>
            </div>
            
            <div class="stat-card">
                <h3>Processing Rate</h3>
                <div class="stat-value" id="processing-rate">0</div>
                <div class="stat-description">Logs per second</div>
            </div>
        </div>
        
        <!-- Visualizations -->
        <div class="visualization-grid">
            <div class="chart-container">
                <h3>üìä Cluster Distribution</h3>
                <div id="cluster-distribution-chart" style="height: 300px;"></div>
            </div>
            
            <div class="chart-container">
                <h3>üìà Pattern Timeline</h3>
                <div id="pattern-timeline-chart" style="height: 300px;"></div>
            </div>
        </div>
        
        <div class="chart-container">
            <h3>üó∫Ô∏è Cluster Visualization</h3>
            <div id="cluster-scatter-plot" style="height: 400px;"></div>
        </div>
        
        <!-- Pattern Discovery Section -->
        <div class="pattern-discovery-container">
            <h3>üîç Pattern Discovery</h3>
            <div class="pattern-controls">
                <button id="refresh-patterns" class="btn-primary">üîÑ Refresh Patterns</button>
                <select id="pattern-filter" class="pattern-filter">
                    <option value="all">All Patterns</option>
                    <option value="error_pattern">Error Patterns</option>
                    <option value="security_pattern">Security Patterns</option>
                    <option value="performance_pattern">Performance Patterns</option>
                    <option value="general_pattern">General Patterns</option>
                </select>
            </div>
            <div id="patterns-grid" class="patterns-grid">
                <p style="color: #7f8c8d; text-align: center; grid-column: 1 / -1;">No patterns discovered yet...</p>
            </div>
        </div>
        
        <!-- Alerts -->
        <div class="alerts-container">
            <h3>üö® Recent Alerts</h3>
            <div id="alerts-list">
                <p style="color: #7f8c8d; text-align: center;">No alerts yet...</p>
            </div>
        </div>
    </div>
    
    <script>
        class ClusteringDashboard {
            constructor() {
                this.ws = null;
                this.isConnected = false;
                this.stats = {
                    totalClusters: 0,
                    patternsDiscovered: 0,
                    anomaliesDetected: 0,
                    processingRate: 0
                };
                this.alerts = [];
                this.clusterData = [];
                this.patternTimeline = [];
                this.demoActive = false;
                this.demoIntervals = [];
                
                this.initializeWebSocket();
                this.initializeCharts();
                this.updateConnectionStatus();
            }
            
            initializeWebSocket() {
                const wsUrl = `ws://${window.location.host}/ws`;
                this.ws = new WebSocket(wsUrl);
                
                this.ws.onopen = () => {
                    this.isConnected = true;
                    this.updateConnectionStatus();
                    console.log('WebSocket connected');
                    
                    // Start periodic stats updates
                    this.startPeriodicUpdates();
                };
                
                this.ws.onclose = () => {
                    this.isConnected = false;
                    this.updateConnectionStatus();
                    console.log('WebSocket disconnected');
                    
                    // Stop periodic updates
                    this.stopPeriodicUpdates();
                    
                    // Reconnect after 5 seconds
                    setTimeout(() => this.initializeWebSocket(), 5000);
                };
                
                this.ws.onmessage = (event) => {
                    const message = JSON.parse(event.data);
                    this.handleMessage(message);
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            }
            
            startPeriodicUpdates() {
                this.updateInterval = setInterval(() => {
                    this.requestStatsUpdate();
                }, 10000); // Update every 10 seconds
            }
            
            stopPeriodicUpdates() {
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }
            }
            
            requestStatsUpdate() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'request_stats',
                        timestamp: new Date().toISOString()
                    }));
                }
            }
            
            handleMessage(message) {
                switch (message.type) {
                    case 'new_cluster':
                        this.handleNewCluster(message.data);
                        break;
                    case 'anomaly_alert':
                        this.handleAnomalyAlert(message.data);
                        break;
                    case 'pattern_discovery':
                        this.handlePatternDiscovery(message.data);
                        break;
                    case 'stats_update':
                        this.handleStatsUpdate(message.data);
                        break;
                    case 'patterns_response':
                        this.handlePatternsResponse(message.data);
                        break;
                }
            }
            
            handleNewCluster(data) {
                this.stats.totalClusters++;
                this.clusterData.push(data);
                this.updateStats();
                this.updateClusterVisualization();
            }
            
            handleAnomalyAlert(data) {
                this.stats.anomaliesDetected++;
                this.addAlert('anomaly', `Anomaly detected: ${data.pattern_type || 'Unknown'}`, data.timestamp);
                this.updateStats();
            }
            
            handlePatternDiscovery(data) {
                this.stats.patternsDiscovered++;
                this.patternTimeline.push({
                    timestamp: data.discovered_at,
                    pattern_type: data.pattern_type,
                    confidence: data.confidence
                });
                this.addAlert('pattern', `New pattern discovered: ${data.pattern_type}`, data.discovered_at);
                this.updateStats();
                this.updatePatternTimeline();
                this.addPatternToGrid(data);
            }
            
            handleStatsUpdate(data) {
                if (data.algorithms) {
                    this.stats.totalClusters = Object.values(data.algorithms)
                        .reduce((sum, algo) => sum + (algo.clusters || 0), 0);
                }
                this.stats.patternsDiscovered = data.total_patterns_discovered || this.stats.patternsDiscovered;
                this.updateStats();
                this.updateClusterDistribution(data.algorithms);
            }
            
            addAlert(type, message, timestamp) {
                this.alerts.unshift({
                    type: type,
                    message: message,
                    timestamp: timestamp || new Date().toISOString()
                });
                
                // Keep only last 10 alerts
                this.alerts = this.alerts.slice(0, 10);
                this.updateAlerts();
            }
            
            updateConnectionStatus() {
                const statusEl = document.getElementById('connection-status');
                if (this.isConnected) {
                    statusEl.textContent = 'üü¢ Connected';
                    statusEl.className = 'connection-status connected';
                } else {
                    statusEl.textContent = 'üî¥ Disconnected';
                    statusEl.className = 'connection-status disconnected';
                }
            }
            
            updateStats() {
                document.getElementById('total-clusters').textContent = this.stats.totalClusters;
                document.getElementById('patterns-discovered').textContent = this.stats.patternsDiscovered;
                document.getElementById('anomalies-detected').textContent = this.stats.anomaliesDetected;
                document.getElementById('processing-rate').textContent = this.stats.processingRate;
            }
            
            updateAlerts() {
                const alertsList = document.getElementById('alerts-list');
                if (this.alerts.length === 0) {
                    alertsList.innerHTML = '<p style="color: #7f8c8d; text-align: center;">No alerts yet...</p>';
                    return;
                }
                
                alertsList.innerHTML = this.alerts.map(alert => `
                    <div class="alert-item alert-${alert.type}">
                        <strong>${alert.message}</strong><br>
                        <small>${new Date(alert.timestamp).toLocaleString()}</small>
                    </div>
                `).join('');
            }
            
            initializeCharts() {
                // Initialize empty charts
                this.updateClusterDistribution({});
                this.updatePatternTimeline();
                this.updateClusterVisualization();
            }
            
            updateClusterDistribution(algorithms) {
                const data = Object.keys(algorithms || {}).map(algoName => ({
                    x: [algoName],
                    y: [algorithms[algoName].clusters || 0],
                    type: 'bar',
                    name: algoName.toUpperCase(),
                    marker: {
                        color: algoName === 'kmeans' ? '#3498db' : 
                              algoName === 'dbscan' ? '#e74c3c' : '#2ecc71'
                    }
                }));
                
                const layout = {
                    title: '',
                    xaxis: { title: 'Algorithm' },
                    yaxis: { title: 'Number of Clusters' },
                    margin: { t: 30 },
                    showlegend: false,
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    paper_bgcolor: 'rgba(0,0,0,0)'
                };
                
                Plotly.newPlot('cluster-distribution-chart', data, layout, {responsive: true});
            }
            
            updatePatternTimeline() {
                if (this.patternTimeline.length === 0) {
                    const emptyLayout = {
                        title: '',
                        margin: { t: 30 },
                        plot_bgcolor: 'rgba(0,0,0,0)',
                        paper_bgcolor: 'rgba(0,0,0,0)',
                        annotations: [{
                            x: 0.5,
                            y: 0.5,
                            xref: 'paper',
                            yref: 'paper',
                            text: 'No patterns discovered yet',
                            showarrow: false,
                            font: { color: '#7f8c8d' }
                        }]
                    };
                    Plotly.newPlot('pattern-timeline-chart', [], emptyLayout, {responsive: true});
                    return;
                }
                
                const data = [{
                    x: this.patternTimeline.map(p => p.timestamp),
                    y: this.patternTimeline.map(p => p.confidence),
                    mode: 'markers+lines',
                    type: 'scatter',
                    name: 'Pattern Confidence',
                    marker: { color: '#3498db', size: 8 },
                    line: { color: '#3498db' }
                }];
                
                const layout = {
                    title: '',
                    xaxis: { title: 'Time' },
                    yaxis: { title: 'Confidence' },
                    margin: { t: 30 },
                    showlegend: false,
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    paper_bgcolor: 'rgba(0,0,0,0)'
                };
                
                Plotly.newPlot('pattern-timeline-chart', data, layout, {responsive: true});
            }
            
            updateClusterVisualization() {
                // Simulated 2D projection of clusters for visualization
                const data = this.clusterData.slice(-100).map((cluster, idx) => ({
                    x: Math.random() * 10 - 5 + (cluster.cluster_id || 0),
                    y: Math.random() * 10 - 5 + (cluster.confidence || 0.5) * 10,
                    cluster: cluster.cluster_id || 0,
                    algorithm: cluster.algorithm || 'unknown'
                }));
                
                const algorithms = [...new Set(data.map(d => d.algorithm))];
                const traces = algorithms.map(algo => ({
                    x: data.filter(d => d.algorithm === algo).map(d => d.x),
                    y: data.filter(d => d.algorithm === algo).map(d => d.y),
                    mode: 'markers',
                    type: 'scatter',
                    name: algo.toUpperCase(),
                    marker: {
                        size: 8,
                        color: algo === 'kmeans' ? '#3498db' : 
                              algo === 'dbscan' ? '#e74c3c' : '#2ecc71'
                    }
                }));
                
                const layout = {
                    title: '',
                    xaxis: { title: 'Component 1' },
                    yaxis: { title: 'Component 2' },
                    margin: { t: 30 },
                    plot_bgcolor: 'rgba(0,0,0,0)',
                    paper_bgcolor: 'rgba(0,0,0,0)',
                    showlegend: true,
                    legend: { x: 0, y: 1 }
                };
                
                if (traces.length > 0) {
                    Plotly.newPlot('cluster-scatter-plot', traces, layout, {responsive: true});
                } else {
                    const emptyLayout = {
                        ...layout,
                        annotations: [{
                            x: 0.5,
                            y: 0.5,
                            xref: 'paper',
                            yref: 'paper',
                            text: 'No cluster data available yet',
                            showarrow: false,
                            font: { color: '#7f8c8d' }
                        }]
                    };
                    Plotly.newPlot('cluster-scatter-plot', [], emptyLayout, {responsive: true});
                }
            }
            
            // Pattern Discovery Methods
            addPatternToGrid(patternData) {
                const patternsGrid = document.getElementById('patterns-grid');
                
                // Remove "no patterns" message if it exists
                const noPatternsMsg = patternsGrid.querySelector('p');
                if (noPatternsMsg && noPatternsMsg.textContent.includes('No patterns discovered yet')) {
                    noPatternsMsg.remove();
                }
                
                const patternCard = this.createPatternCard(patternData);
                patternsGrid.insertBefore(patternCard, patternsGrid.firstChild);
                
                // Keep only last 20 patterns
                const cards = patternsGrid.querySelectorAll('.pattern-card');
                if (cards.length > 20) {
                    cards[cards.length - 1].remove();
                }
            }
            
            createPatternCard(patternData) {
                const card = document.createElement('div');
                card.className = `pattern-card ${this.getPatternClass(patternData.pattern_type)}`;
                
                const confidencePercent = Math.round(patternData.confidence * 100);
                const algorithm = patternData.algorithm || 'unknown';
                const timestamp = patternData.discovered_at || new Date().toISOString();
                
                // Generate sample logs if not provided
                const sampleLogs = patternData.sample_logs || [
                    `Sample log for ${patternData.pattern_type}`,
                    `Another example of ${patternData.pattern_type}`,
                    `Pattern instance: ${patternData.pattern_type}`
                ];
                
                // Generate feature importance if not provided
                const featureImportance = patternData.feature_importance || {
                    'response_time': Math.random() * 0.3 + 0.1,
                    'status_code': Math.random() * 0.2 + 0.1,
                    'service': Math.random() * 0.2 + 0.1,
                    'level': Math.random() * 0.2 + 0.1,
                    'source_ip': Math.random() * 0.1 + 0.05
                };
                
                card.innerHTML = `
                    <div class="pattern-header">
                        <div class="pattern-type">${this.formatPatternType(patternData.pattern_type)}</div>
                        <div class="pattern-confidence">${confidencePercent}%</div>
                    </div>
                    <div class="pattern-algorithm">Algorithm: ${algorithm.toUpperCase()}</div>
                    
                    <div class="pattern-samples">
                        <h4>Sample Logs:</h4>
                        ${sampleLogs.slice(0, 3).map(log => `
                            <div class="sample-log" title="${log}">${log}</div>
                        `).join('')}
                    </div>
                    
                    <div class="pattern-features">
                        <h4>Feature Importance:</h4>
                        ${Object.entries(featureImportance).map(([feature, importance]) => `
                            <div class="feature-bar">
                                <div class="feature-name">${feature}</div>
                                <div class="feature-progress">
                                    <div class="feature-fill" style="width: ${importance * 100}%"></div>
                                </div>
                                <div class="feature-value">${Math.round(importance * 100)}%</div>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="pattern-timestamp">${new Date(timestamp).toLocaleString()}</div>
                `;
                
                return card;
            }
            
            getPatternClass(patternType) {
                const typeMap = {
                    'error_pattern': 'error',
                    'security_pattern': 'security',
                    'performance_pattern': 'performance',
                    'general_pattern': 'general'
                };
                return typeMap[patternType] || 'general';
            }
            
            formatPatternType(patternType) {
                return patternType.replace('_', ' ').replace(/\b\w/g, l => l.toUpperCase());
            }
            
            filterPatterns(filterValue) {
                const cards = document.querySelectorAll('.pattern-card');
                cards.forEach(card => {
                    if (filterValue === 'all') {
                        card.style.display = 'block';
                    } else {
                        const patternType = card.querySelector('.pattern-type').textContent.toLowerCase().replace(' ', '_');
                        card.style.display = patternType === filterValue ? 'block' : 'none';
                    }
                });
            }
            
            refreshPatterns() {
                // Request fresh pattern data from server
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        type: 'request_patterns',
                        timestamp: new Date().toISOString()
                    }));
                }
            }
            
            handlePatternsResponse(data) {
                const patternsGrid = document.getElementById('patterns-grid');
                
                // Clear existing patterns
                patternsGrid.innerHTML = '';
                
                if (data.patterns && data.patterns.length > 0) {
                    // Add each pattern to the grid
                    data.patterns.forEach(pattern => {
                        this.addPatternToGrid(pattern);
                    });
                } else {
                    // Show no patterns message
                    patternsGrid.innerHTML = '<p style="color: #7f8c8d; text-align: center; grid-column: 1 / -1;">No patterns discovered yet...</p>';
                }
            }
            
            // Demo control methods
            startDemo() {
                if (this.demoActive) return;
                
                this.demoActive = true;
                this.updateDemoButtonState();
                
                // Clear existing data
                this.alerts = [];
                this.clusterData = [];
                this.patternTimeline = [];
                this.updateAlerts();
                this.updatePatternTimeline();
                this.updateClusterVisualization();
                
                // Reset stats
                this.stats = {
                    totalClusters: 0,
                    patternsDiscovered: 0,
                    anomaliesDetected: 0,
                    processingRate: 0
                };
                this.updateStats();
                
                // Start demo simulation
                this.simulateDemoData();
                
                // Add demo notification
                this.addAlert('pattern', 'üé¨ Demo mode activated - Watch for pattern discoveries!', new Date().toISOString());
            }
            
            stopDemo() {
                if (!this.demoActive) return;
                
                this.demoActive = false;
                this.updateDemoButtonState();
                
                // Clear all demo intervals
                this.demoIntervals.forEach(interval => clearTimeout(interval));
                this.demoIntervals = [];
                
                // Add demo stopped notification
                this.addAlert('pattern', '‚èπÔ∏è Demo mode stopped', new Date().toISOString());
            }
            
            updateDemoButtonState() {
                const demoBtn = document.getElementById('demo-button');
                const stopBtn = document.getElementById('stop-demo-button');
                
                if (this.demoActive) {
                    demoBtn.style.display = 'none';
                    stopBtn.style.display = 'block';
                    demoBtn.classList.add('demo-active');
                } else {
                    demoBtn.style.display = 'block';
                    stopBtn.style.display = 'none';
                    demoBtn.classList.remove('demo-active');
                }
            }
            
            // Simulate demo data with continuous updates
            simulateDemoData() {
                // Initial stats update
                const statsInterval = setTimeout(() => {
                    this.handleStatsUpdate({
                        algorithms: {
                            kmeans: { clusters: 5, total_points: 150 },
                            dbscan: { clusters: 3, total_points: 150 },
                            hdbscan: { clusters: 4, total_points: 150 }
                        },
                        total_patterns_discovered: 7
                    });
                }, 2000);
                this.demoIntervals.push(statsInterval);
                
                // Simulate pattern discoveries
                const patternTypes = ['error_pattern', 'security_pattern', 'performance_pattern', 'general_pattern'];
                const algorithms = ['kmeans', 'dbscan', 'hdbscan'];
                
                patternTypes.forEach((patternType, index) => {
                    const patternInterval = setTimeout(() => {
                        if (!this.demoActive) return;
                        
                        this.handlePatternDiscovery({
                            pattern_type: patternType,
                            algorithm: algorithms[index % algorithms.length],
                            confidence: 0.7 + Math.random() * 0.25,
                            discovered_at: new Date().toISOString(),
                            sample_logs: [
                                `Sample ${patternType} log entry 1`,
                                `Another ${patternType} occurrence`,
                                `Pattern instance: ${patternType}`
                            ],
                            feature_importance: {
                                'response_time': Math.random() * 0.3 + 0.1,
                                'status_code': Math.random() * 0.2 + 0.1,
                                'service': Math.random() * 0.2 + 0.1,
                                'level': Math.random() * 0.2 + 0.1,
                                'source_ip': Math.random() * 0.1 + 0.05
                            }
                        });
                    }, 4000 + (index * 2000));
                    this.demoIntervals.push(patternInterval);
                });
                
                // Simulate anomaly alert
                const anomalyInterval = setTimeout(() => {
                    if (!this.demoActive) return;
                    
                    this.handleAnomalyAlert({
                        pattern_type: 'unusual_access_pattern',
                        severity: 'high',
                        timestamp: new Date().toISOString()
                    });
                }, 12000);
                this.demoIntervals.push(anomalyInterval);
                
                // Continuous pattern generation
                const continuousPatternInterval = setInterval(() => {
                    if (!this.demoActive) {
                        clearInterval(continuousPatternInterval);
                        return;
                    }
                    
                    const randomPatternType = patternTypes[Math.floor(Math.random() * patternTypes.length)];
                    const randomAlgorithm = algorithms[Math.floor(Math.random() * algorithms.length)];
                    
                    this.handlePatternDiscovery({
                        pattern_type: randomPatternType,
                        algorithm: randomAlgorithm,
                        confidence: 0.6 + Math.random() * 0.3,
                        discovered_at: new Date().toISOString(),
                        sample_logs: [
                            `Continuous ${randomPatternType} detection`,
                            `Real-time ${randomPatternType} analysis`,
                            `Live ${randomPatternType} monitoring`
                        ],
                        feature_importance: {
                            'response_time': Math.random() * 0.3 + 0.1,
                            'status_code': Math.random() * 0.2 + 0.1,
                            'service': Math.random() * 0.2 + 0.1,
                            'level': Math.random() * 0.2 + 0.1,
                            'source_ip': Math.random() * 0.1 + 0.05
                        }
                    });
                }, 8000); // New pattern every 8 seconds
                this.demoIntervals.push(continuousPatternInterval);
            }
            
            // Legacy method for URL-based demo
            simulateData() {
                this.startDemo();
            }
        }
        
        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const dashboard = new ClusteringDashboard();
            
            // Add event listeners for pattern discovery controls
            document.getElementById('refresh-patterns').addEventListener('click', () => {
                dashboard.refreshPatterns();
            });
            
            document.getElementById('pattern-filter').addEventListener('change', (e) => {
                dashboard.filterPatterns(e.target.value);
            });
            
            // Add event listeners for demo controls
            document.getElementById('demo-button').addEventListener('click', () => {
                dashboard.startDemo();
            });
            
            document.getElementById('stop-demo-button').addEventListener('click', () => {
                dashboard.stopDemo();
            });
            
            // Simulate some data if in demo mode (legacy URL parameter)
            if (window.location.search.includes('demo=true')) {
                dashboard.simulateData();
            }
        });
    </script>
</body>
</html>
